(ns redeemed.server
  (:require [compojure.core :refer [defroutes GET POST PUT DELETE]]
            [compojure.route :as route]
            [ring.adapter.jetty :refer [run-jetty]]
            [ring.middleware.json :refer [wrap-json-response wrap-json-body]]
            [ring.middleware.params :refer [wrap-params]]
            [ring.middleware.keyword-params :refer [wrap-keyword-params]]
            [ring.util.response :refer [response status]]
            [jsonista.core :as json]
            [clojure.tools.logging :as log]
            [clojure.string :as str])
  (:import [org.apache.jena.tdb2 TDB2Factory]
           [org.apache.jena.query QueryFactory QueryExecutionFactory]
           [org.apache.jena.rdf.model ModelFactory]
           [java.time LocalDate]
           [java.time.format DateTimeFormatter]))

;; Database connection
(defn get-dataset []
  (let [dataset-path (or (System/getenv "JENA_DB_PATH") "data/tdb2")]
    (TDB2Factory/connectDataset dataset-path)))

;; SPARQL query execution
(defn execute-sparql-select [query-string]
  (let [dataset (get-dataset)]
    (try
      (.begin dataset)
      (let [model (.getDefaultModel dataset)
            query (QueryFactory/create query-string)
            qexec (QueryExecutionFactory/create query model)
            results (.execSelect qexec)
            result-list (atom [])]
        
        (while (.hasNext results)
          (let [soln (.nextSolution results)
                vars (.varNames soln)
                row (reduce (fn [acc var]
                              (let [node (.get soln var)]
                                (assoc acc (keyword var)
                                       (cond
                                         (.isResource node) (.getURI node)
                                         (.isLiteral node) (.getLexicalForm node)
                                         :else (.toString node)))))
                            {} vars)]
            (swap! result-list conj row)))
        
        (.close qexec)
        @result-list)
      
      (catch Exception e
        (log/error e "Error executing SPARQL query")
        [])
      
      (finally
        (.close dataset)))))

;; API endpoint handlers
(defn list-contacts []
  (let [query "
    PREFIX foaf: <http://xmlns.com/foaf/0.1/>
    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    
    SELECT ?person ?name ?givenName ?familyName WHERE {
      ?person a foaf:Person .
      ?person foaf:name ?name .
      OPTIONAL { ?person foaf:givenName ?givenName }
      OPTIONAL { ?person foaf:familyName ?familyName }
    }
    ORDER BY ?name"]
    
    (response {:contacts (execute-sparql-select query)})))

(defn get-contact-by-name [full-name]
  (let [escaped-name (str/replace full-name "\"" "\\\"")
        query (str "
    PREFIX foaf: <http://xmlns.com/foaf/0.1/>
    PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    
    SELECT ?person ?name ?givenName ?familyName ?event ?eventLabel ?eventTime WHERE {
      ?person a foaf:Person .
      ?person foaf:name \"" escaped-name "\" .
      OPTIONAL { ?person foaf:givenName ?givenName }
      OPTIONAL { ?person foaf:familyName ?familyName }
      OPTIONAL { 
        ?event event:agent ?person .
        ?event rdfs:label ?eventLabel .
        OPTIONAL { ?event event:time ?eventTime }
      }
    }")]
    
    (let [results (execute-sparql-select query)]
      (if (empty? results)
        (status (response {:error "Contact not found"}) 404)
        (response {:contact (first results)
                   :events (map #(select-keys % [:event :eventLabel :eventTime]) results)})))))

(defn list-events-in-range [start-date end-date]
  (let [query (str "
    PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
    PREFIX schema: <http://schema.org/>
    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    PREFIX foaf: <http://xmlns.com/foaf/0.1/>
    
    SELECT ?event ?label ?time ?startDate ?agent ?agentName ?place ?placeLabel WHERE {
      ?event a event:Event .
      OPTIONAL { ?event rdfs:label ?label }
      OPTIONAL { ?event event:time ?time }
      OPTIONAL { ?event schema:startDate ?startDate }
      OPTIONAL { 
        ?event event:agent ?agent .
        ?agent foaf:name ?agentName 
      }
      OPTIONAL { 
        ?event event:place ?place .
        ?place rdfs:label ?placeLabel 
      }
      
      FILTER (
        (BOUND(?time) && ?time >= \"" start-date "T00:00:00\"^^<http://www.w3.org/2001/XMLSchema#dateTime> && 
         ?time <= \"" end-date "T23:59:59\"^^<http://www.w3.org/2001/XMLSchema#dateTime>) ||
        (BOUND(?startDate) && ?startDate >= \"" start-date "T00:00:00\"^^<http://www.w3.org/2001/XMLSchema#dateTime> && 
         ?startDate <= \"" end-date "T23:59:59\"^^<http://www.w3.org/2001/XMLSchema#dateTime>)
      )
    }
    ORDER BY ?time ?startDate")]
    
    (response {:events (execute-sparql-select query)
               :date-range {:start start-date :end end-date}})))

(defn list-places []
  (let [query "
    PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
    PREFIX schema: <http://schema.org/>
    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    
    SELECT ?place ?label ?lat ?long ?type WHERE {
      ?place a geo:SpatialThing .
      OPTIONAL { ?place rdfs:label ?label }
      OPTIONAL { ?place geo:lat ?lat }
      OPTIONAL { ?place geo:long ?long }
      OPTIONAL { 
        ?place a ?type .
        FILTER(?type != <http://www.w3.org/2003/01/geo/wgs84_pos#SpatialThing>)
      }
    }
    ORDER BY ?label"]
